(function() {
  var File, Pathfinder, Project, fs, mint, _path;
  mint = require('mint');
  _path = require('path');
  fs = require('fs');
  Pathfinder = require('pathfinder');
  File = Pathfinder.File;
  Project = require("design.io").project;
  module.exports = function() {
    var args, compressor, debug, ignore, importPaths, options, outputPath, pathfinder, preprocess, project, touchDependencies, write, writeMethod;
    project = Project.find();
    pathfinder = project.pathfinder;
    args = Array.prototype.slice.call(arguments, 0, arguments.length);
    options = typeof args[args.length - 1] === "object" ? args.pop() : {};
    if (!(args.length > 0)) {
      args[0] = /\.(styl|less|sass|scss|css)$/;
    }
    if (options.hasOwnProperty("patterns")) {
      args[0] || (args[0] = options.patterns);
    }
    outputPath = options.outputPath;
    writeMethod = options.write;
    importPaths = options.paths || [];
    debug = options.hasOwnProperty("debug") && options.debug === true;
    ignore = options.ignore;
    preprocess = options.preprocess;
    if (options.hasOwnProperty("compress") && options.compress === true) {
      compressor = mint.yui;
    }
    write = function(path, string) {
      var _outputPath;
      if (writeMethod) {
        return writeMethod.call(this, path, string);
      } else if (outputPath) {
        _outputPath = outputPath.call(this, path);
        if (_outputPath) {
          return File.write(_outputPath, string);
        }
      }
    };
    touchDependencies = function(file) {
      var dependentPath, dependentPaths, _i, _len, _results;
      dependentPaths = pathfinder.dependsOn(file.absolutePath());
      if (dependentPaths && dependentPaths.length > 0) {
        _results = [];
        for (_i = 0, _len = dependentPaths.length; _i < _len; _i++) {
          dependentPath = dependentPaths[_i];
          _results.push(File.touch(dependentPath));
        }
        return _results;
      }
    };
    return project.createWatcher(args, {
      ignore: ignore,
      toSlug: function(path) {
        return path.replace(process.cwd() + '/', '').replace(/[\/\.]/g, '-');
      },
      initialize: function(path, callback) {
        var parts;
        parts = path.split("/");
        if (parts[parts.length - 1].match(/^_/)) {
          return callback();
        } else {
          return this.update(path, callback);
        }
      },
      update: function(path, callback) {
        var self;
        self = this;
        return pathfinder.compile(path, {
          preprocess: preprocess,
          renderOptions: {
            paths: importPaths
          }
        }, function(error, string, file) {
          if (error) {
            return self.error(error, callback);
          }
          if (compressor) {
            return compressor.render(string, function(error, result) {
              if (error) {
                return callback(error);
              }
              self.broadcast({
                body: result,
                slug: self.toSlug(path)
              });
              write.call(self, path, result);
              touchDependencies(file);
              return callback();
            });
          } else {
            self.broadcast({
              body: string,
              slug: self.toSlug(path)
            });
            write.call(self, path, string);
            touchDependencies(file);
            return callback();
          }
        });
      },
      client: {
        connect: function() {
          return this.stylesheets = {};
        },
        update: function(data) {
          var node;
          if (this.stylesheets[data.slug] !== null) {
            node = this.stylesheets[data.slug];
          } else {
            node = $("link[href='" + data.url + "']");
          }
          if (node) {
            if (data.url) {
              node.attr("href", "" + data.url + "?" + ((new Date()).getTime().toString()));
            } else {
              node.text(data.body);
            }
          } else {
            node = $("<style id='" + data.slug + "' type='text/css'>" + data.body + "</style>");
            $("body").append(node);
          }
          console.log("Updated " + (data.url || data.path));
          return this.stylesheets[data.slug] = node;
        },
        destroy: function(data) {
          if (this.stylesheets[data.slug] != null) {
            return this.stylesheets[data.slug].remove();
          }
        }
      },
      server: {
        update: function(data) {}
      }
    });
  };
}).call(this);
